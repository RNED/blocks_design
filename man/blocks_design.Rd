% Generated by roxygen2 (4.0.2): do not edit by hand
\name{blocks_design}
\alias{blocks_design}
\title{Block designs}
\usage{
blocks_design(treatments, replicates, blocklevels = hcf, searches = min(64,
  floor(4096/nunits)))
}
\arguments{
\item{treatments}{A list of treatment replication sets showing the number of treatments in each replication set of the design.}

\item{replicates}{A list of replication numbers for each replication set in the design.
The treatments and replications lists must be equal in length and each matching pair represents
a set of treatments with a given replication.}

\item{blocklevels}{An optional list of nested blocks.
The numbers in the list define the number of nested blocks in each blocks stratum with the first number
giving the number of main blocks and the succesive numbers, if any, giving the number of nested
blocks in each preceding block. The default is a maximal set of complete orthogonal randomised blocks.}

\item{searches}{An optional parameter for the number of local optima searched during
a design optimization. The default setting decreases with increasing design size.}
}
\value{
\item{Design}{Data frame showing block and treatment factors for each plot}
\item{Plan}{Data frame showing treatments allocation to plots for each block}
\item{Incidences[[i]]}{Blocks by treatments incidence matrices  i=1... for each stratum in the design}
\item{Efficiencies}{Data frame showing the A-efficiency and an upper bound, where available, for each stratum in the design}
}
\description{
\code{blocks_design} Block designs for unstructured treatments with arbitrary replication and arbitrary depth of nesting
}
\details{
Constructs nested block designs for unstructured treatment sets where treatments can have arbitrary replication
and blocks can be nested to any feasible depth of nesting. Block sizes in the same stratum
are as equal as possible and never differ by more than a single plot. Blocks strata are optimized hierarchically with the blocks of each new set
optimized within the blocks of the preceding set with the constraint that the treatments of the existing blocks remain unchanged.

In general, blocks are  optimized algorithmically by a swapping algorithm that maximizes the determinant of
the information matrix (D-optimality) but certain special lattice designs (see vignette) are constructed algebraically.
Lattice designs with number of treatments equal to the square of a prime-power are constructed using results from the \code{\link{crossdes}} package.

The treatment design is any combination of treatment sets with arbitrary levels of replication where the treatment numbers and replication levels for
each treatment sets are matching pairs of numbers from treatment and replication parameter lists. Treatments are numbered consecutively according to
the ordering of the treatment sets in the parameter lists (see the first example below).

Treatments are fully randomized within the bottom blocks of the design and each set of nested blocks is randomized within the levels of the
next higher set of blocks.

The outputs include the achieved A-efficiency of each blocks stratum and where available, an A-efficiency upper bound. Where achieved efficiency is less
than the upper-bound or where no bound is available the design optimization should be repeated a number of times to examine the stability of the
 achieved efficiencies.
}
\examples{
# incidences for 2 replicates of 3 treatments, 4 replicates of 2 treatments and 3 replicates of 4 treatments in single randomized layout
blocks_design(treatments=c(3,2,4),replicates=c(2,4,3))$Incidences[[1]]

# 4 replicates of 50 treatments in complete randomized blocks
blocks_design(treatments=50,replicates=4)

blocks_design(treatments=50,replicates=4,blocklevels=c(4,5))

# as above but with 20 additional single replicate treatments
blocks_design(treatments=c(50,20),replicates=c(4,1),blocklevels=c(4,5))

# tabulation of 4 replicates of 4 treatments and 8 replicates of 1 treatment with 4 main blocks and 8 nested blocks in each main block
table(blocks_design(treatments=c(4,1),replicates=c(4,8))$Design)

# concurrences for 3 replicates of 36 treatments with 3 main blocks and 6 nested blocks
crossprod(blocks_design(treatments=36,replicates=3,blocklevels=c(3,6))$Incidences[[2]])

# 4 replicates of 64 treatments with 4 main blocks and five 2-level nesting factors
blocks_design(treatments=64,replicates=4,blocklevels=c(4,2,2,2,2,2))

# 9 replicates of 19 treatments in 19 blocks with extra searches (may require even more for a BIB solution)
blocks_design(19,9,19,searches=1000)
}

